-- Idris 2

module System.Concurrency.BufferedChannel

import System.Concurrency.Queue

import Data.IORef
import System.Concurrency

export
record BufferedChannel where
  constructor MkBufferedChannel
  inbox : IORef Queue
-- Queues are already MT-Safe
--  iLock : Mutex

  iCondLock : Mutex
  iCondVar : Condition

  outbox : IORef Queue
-- Queues are already MT-Safe
--  oLock : Mutex

  oCondLock : Mutex
  oCondVar : Condition


---------------------------
-- CONSTRUCTOR FUNCTIONS --
---------------------------

||| Create a new BufferedChannel.
export
makeBufferedChannel : IO (IORef BufferedChannel)
makeBufferedChannel = do iQueue <- makeQueue
                         iCondLock <- makeMutex
                         iCondVar <- makeCondition
                         -- ^ inbox things
                         -- v outbox things
                         oQueue <- makeQueue
                         oCondLock <- makeMutex
                         oCondVar <- makeCondition
                         -- create the channel in an IORef
                         newIORef (MkBufferedChannel iQueue iCondLock iCondVar
                                                     oQueue oCondLock oCondVar)

||| Given an IORef to a BufferedChannel, obtained through the `makeBufferedChannel` function,
||| create a version which is primarily used for sending messages.
export
makeSender : (cRef : IORef BufferedChannel) -> IO BufferedChannel
makeSender cRef
  = do (MkBufferedChannel inbox iCL iCV outbox oCL oCV) <- readIORef cRef
       pure (MkBufferedChannel inbox iCL iCV outbox oCL oCV)

||| Given an IORef to a BufferedChannel, obtained through the `makeBufferedChannel` function,
||| create a version which is primarily used for receiving messages.
export
makeReceiver : (cRef : IORef BufferedChannel) -> IO BufferedChannel
makeReceiver cRef
  = do (MkBufferedChannel inbox iCL iCV outbox oCL oCV) <- readIORef cRef
       pure (MkBufferedChannel outbox oCL oCV inbox iCL iCV)


------------------------
-- INBOX MANIPULATION --
------------------------

-- Queues are already MT-Safe
--lockInbox : BufferedChannel -> IO ()
--
--unlockInbox : BufferedChannel -> IO ()

-- I don't think there is ever a reason to do this...
--signalInbox : BufferedChannel -> IO ()

||| Wait on the condition variable for the BufferedChannel's inbox.
waitInbox : BufferedChannel -> IO ()
waitInbox (MkBufferedChannel inbox iCondLock iCondVar _ _ _)
  = do 
       conditionWait iCondVar iCondLock

-- OLD IMPLEMENTATION
--  = conditionWait iCondVar iCondLock

||| Wait on the condition variable for the BufferedChannel's inbox, with a timeout in
||| micro-seconds (e-6 s).
waitInboxTimeout : BufferedChannel -> (uSecs : Int) -> IO ()
waitInboxTimeout (MkBufferedChannel inbox iCondLock iCondVar _ _ _) uSecs
  = conditionWaitTimeout iCondVar iCondLock uSecs


-------------------------
-- OUTBOX MANIPULATION --
-------------------------

-- Queues are already MT-Safe
--lockOutbox : BufferedChannel -> IO ()
--
--unlockOutbox : BufferedChannel -> IO ()

||| Unlock at least one of the threads currently waiting on the outbox's
||| condition variable.
|||
||| On a *nix system, see `man 3 pthread_cond_broadcast` for more details
||| regarding the difference between this function and the `broadcastOutbox`
||| function.
signalOutbox : BufferedChannel -> IO ()
signalOutbox (MkBufferedChannel _ _ _ outbox oCondLock oCondVar)
  = conditionSignal oCondVar

||| Unlock all of the threads currently waiting on the outbox's condition
||| variable.
|||
||| On a *nix system, see `man 3 pthread_cond_broadcast` for more details
||| regarding the difference between this function and the `signalOutbox`
||| function.
broadcastOutbox : BufferedChannel -> IO ()
broadcastOutbox (MkBufferedChannel _ _ _ outbox oCondLock oCondVar)
  = conditionBroadcast oCondVar

-- I don't think there is ever a reason to do this...
--waitOutbox : BufferedChannel -> IO ()
--
--waitOutboxTimeout : BufferedChannel -> (uSecs : Int) -> IO ()


-------------
-- SENDING --
-------------

||| Send a Message through the BufferedChannel and *signal* on the condition variable
||| for the BufferedChannel's outbox to indicate to at least one blocking thread
||| blocking on it, that a Message can be received (see `signalOutbox`).
|||
||| @chan: The BufferedChannel to send the Message through.
||| @msg: The Message to send.
|||
||| MT-Safe: YES
export
sendAndSignal : (chan : BufferedChannel) -> (msg : Message) -> IO ()
sendAndSignal chan msg = do enqueue (outbox chan) msg
                            signalOutbox chan

||| Send a Message through the BufferedChannel and *broadcast* on the condition variable
||| for the BufferedChannel's outbox to indicate to all threads currently blocking on
||| it, that a Message can be received (see `signalOutbox`).
|||
||| @chan: The BufferedChannel to send the Message through.
||| @msg: The Message to send.
|||
||| MT-Safe: YES
export
sendAndBroadcast : (chan : BufferedChannel) -> (msg : Message) -> IO ()
sendAndBroadcast chan msg = do enqueue (outbox chan) msg
                               broadcastOutbox chan

---------------
-- RECEIVING --
---------------

||| Receive a Message through the BufferedChannel, if there is one, removing it from the
||| inbox in the process. Does not block but immediately returns `Nothing` if
||| there was no message available.
|||
||| @chan: The BufferedChannel to receive the Message through.
|||
||| MT-Safe: YES
export
receive : (chan : BufferedChannel) -> IO (Maybe Message)
receive chan = dequeue (inbox chan)

||| Similar to `receive`, but blocks on the condition variable of the inbox
||| until a Message is available, at which point it receives the Message,
||| removing it from the inbox in the process.
|||
||| @chan: The BufferedChannel to receive the Message through.
|||
||| MT-Safe: YES
export
await : (chan : BufferedChannel) -> IO (Maybe Message)
await (MkBufferedChannel inbox iCondLock iCondVar _ _ _) =
  do maybeMsg <- dequeue inbox
     case maybeMsg of
          -- if at first you don't succeed...
          Nothing => do mutexAcquire iCondLock   -- see man 3 pthread_cond_await
                        conditionWait iCondVar iCondLock
                        rawMsg <- dequeue inbox
                        mutexRelease iCondLock   -- FIXME: necessary? Yes. Right place for it?
                        pure rawMsg
          justMsg => pure justMsg

--------------
-- PEEK/SPY --
--------------

||| Receive a Message through the BufferedChannel, if there is one, *without* removing
||| from the inbox in the process. Does not block but immediately returns
||| `Nothing` if there was no message available.
|||
||| @chan: The BufferedChannel to receive the Message through.
|||
||| MT-Safe: YES
export
peek : (chan : BufferedChannel) -> IO (Maybe Message)
peek chan = peek (inbox chan)

||| Watches the BufferedChannel until a Message appears, at which point it "reports
||| back" with the Message. Hence, `spy`.
|||
||| Similar to `peek`, but blocks on the condition variable of the inbox until
||| a Message is available, at which point it receives the Message, *without*
||| removing it from the BufferedChannel's inbox in the process.
|||
||| @chan: The BufferedChannel to receive the Message through.
|||
||| MT-Safe: YES
export
spy : (chan : BufferedChannel) -> IO (Maybe Message)
spy (MkBufferedChannel inbox iCondLock iCondVar _ _ _) =
  do maybeMsg <- peek inbox
     case maybeMsg of
          Nothing => do mutexAcquire iCondLock
                        conditionWait iCondVar iCondLock
                        rawMsg <- peek inbox
                        mutexRelease iCondLock
                        pure rawMsg
          justMsg => pure justMsg

